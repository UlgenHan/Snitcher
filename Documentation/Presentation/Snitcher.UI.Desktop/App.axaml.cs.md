# App.axaml.cs

## Overview

`App.axaml.cs` is the main application class for the Snitcher desktop application built with Avalonia UI. It serves as the entry point for dependency injection configuration, service registration, and application lifecycle management. This class is responsible for wiring up the entire application infrastructure including the database layer, UI services, and domain-specific components.

**Why it exists**: To provide centralized application bootstrapping and service container configuration in a clean, maintainable way following modern .NET patterns.

**What problem it solves**: Eliminates scattered service registration, provides consistent dependency injection across all layers, and ensures proper initialization order for complex subsystems like the database and proxy services.

**What would break if removed**: The entire application would fail to start as no services would be registered, the database wouldn't initialize, and the main window would have no data context.

## Tech Stack Identification

**Languages**: C# 12.0 (.NET 8.0)

**Frameworks**:
- Avalonia UI 11.3.10 (Cross-platform desktop UI framework)
- Microsoft.Extensions.Hosting 8.0.1 (Application hosting and DI)
- Microsoft.Extensions.DependencyInjection 8.0.1 (DI container)
- Microsoft.Extensions.Logging 8.0.1 (Logging framework)

**Libraries**:
- CommunityToolkit.Mvvm 8.2.1 (MVVM helpers)
- FluentIcons.Avalonia 2.0.316.1 (Icon library)
- Entity Framework Core (via Snitcher.Repository)
- SQLite (database provider)

**UI Framework**: Avalonia UI with XAML markup

**Persistence**: SQLite database via Entity Framework Core

**Build Tools**: MSBuild with .NET SDK 8.0

**Runtime Assumptions**: Windows desktop environment with .NET 8.0 runtime installed

## Architectural Role

**Layer**: Presentation/Application Bootstrapping

**Responsibility Boundaries**:
- MUST configure all application services
- MUST initialize dependency injection container
- MUST set up main window with proper data context
- MUST NOT contain business logic
- MUST NOT handle UI events directly

**What it MUST do**:
- Register all services in correct order
- Configure database settings
- Initialize logging infrastructure
- Create and display main window
- Handle application lifecycle events

**What it MUST NOT do**:
- Implement business rules
- Handle user interactions
- Manage UI state
- Perform data operations directly

**Dependencies (Incoming)**: None (entry point)

**Dependencies (Outgoing)**: All application layers and services

## Execution Flow

**Where execution starts**: `Main()` method in `Program.cs` calls `BuildAvaloniaApp().StartWithClassicDesktopLifetime(args)`, which eventually calls `OnFrameworkInitializationCompleted()`

**How control reaches this component**:
1. `Program.Main()` → `AppBuilder.Configure<App>()`
2. Avalonia framework creates `App` instance
3. `Initialize()` called for XAML loading
4. `OnFrameworkInitializationCompleted()` called when framework ready

**Call sequence**:
1. `Initialize()` - Load XAML resources
2. `OnFrameworkInitializationCompleted()`:
   - Check application lifetime type
   - Call `ConfigureServices()` to build DI container
   - Create main window with resolved ViewModel
   - Initialize database asynchronously
3. `ConfigureServices()`:
   - Configure logging with debug/release levels
   - Configure Snitcher database (SQLite)
   - Register UI services and ViewModels
   - Register domain services conditionally based on feature flags
   - Register proxy inspection services
   - Build service provider
   - Start database initialization task

**Synchronous vs asynchronous behavior**: Main setup is synchronous, but database initialization runs asynchronously in background to avoid blocking UI startup.

**Threading/Dispatcher notes**: Database initialization runs on background thread via `Task.Run()`, UI operations remain on UI thread.

**Lifecycle**: Created at application start → Lives for entire application duration → Disposed on application shutdown

## Public API / Surface Area

**Constructors**: Default constructor (generated by Avalonia)

**Public Methods**: None (all methods are protected/internal)

**Protected Methods**:
- `Initialize()` - Loads XAML markup
- `OnFrameworkInitializationCompleted()` - Main setup logic

**Private Methods**:
- `ConfigureServices()` - Builds DI container
- `DisableAvaloniaDataAnnotationValidation()` - Validation setup (currently disabled)

**Properties**:
- `ServiceProvider` (static) - Access to DI container for entire application

**Events**: None exposed

**Expected Input/Output**: No direct input/output, configures application infrastructure

**Side Effects**:
- Creates service provider
- Initializes database
- Creates main window
- Registers all application services

**Error Behavior**: Exceptions during service registration will crash application; database initialization errors are logged but don't prevent startup

## Internal Logic Breakdown

**Lines 34-57**: Main framework initialization
```csharp
if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)
{
    _serviceProvider = ConfigureServices();
    desktop.MainWindow = new SnitcherMainWindow
    {
        DataContext = _serviceProvider.GetRequiredService<SnitcherMainViewModel>()
    };
}
```
- Ensures desktop application lifetime
- Builds service provider
- Creates main window with injected ViewModel

**Lines 60-149**: Service configuration
- **Lines 64-74**: Logging setup with conditional debug level
- **Lines 76-88**: Database configuration using SQLite in AppData
- **Lines 90-130**: Service registration with feature flag checks
- **Lines 136-147**: Asynchronous database initialization

**Feature Flag Pattern**: Lines 100-130 use `UIConfiguration.Features.Enable*` flags to conditionally register services, allowing modular feature enablement.

**Error Handling**: Database initialization wrapped in try-catch with logging, preventing startup failures.

## Patterns & Principles Used

**Dependency Injection Pattern**: Constructor injection throughout application, service registration centralized

**Service Locator Pattern**: Static `ServiceProvider` property for legacy access (should be minimized)

**Factory Pattern**: Service provider acts as factory for all services

**Configuration Pattern**: Centralized configuration with feature flags

**Async/Await Pattern**: Non-blocking database initialization

**Why these patterns were chosen**:
- DI for testability and loose coupling
- Feature flags for modular architecture
- Async init for responsive startup
- Centralized config for maintainability

**Trade-offs**:
- Service locator provides global access but reduces testability
- Feature flags add complexity but enable modular development
- Async init improves UX but adds complexity

**Anti-patterns avoided**:
- No static service instances
- No direct database access in UI layer
- No hardcoded dependencies

## Binding / Wiring / Configuration

**Dependency Injection**:
- Uses Microsoft.Extensions.DependencyInjection
- Scoped services for ViewModels
- Singleton services for infrastructure
- Transient services for lightweight objects

**Data Binding**: None (this is code-behind, not a ViewModel)

**Configuration Sources**:
- `UIConfiguration.Features` class for feature flags
- Environment-specific compilation directives
- Hardcoded database path with environment variable

**Runtime Wiring**:
- Service provider built in `ConfigureServices()`
- Main window DataContext set from resolved service
- Database initialization triggered after provider built

**Registration Points**:
- Lines 91-93: Core UI services
- Lines 96-98: Core ViewModels  
- Lines 100-130: Conditional domain services
- Lines 124-130: Proxy inspection services

## Example Usage

**Minimal Example**:
```csharp
// Access service from anywhere in application
var logger = App.ServiceProvider?.GetService<ILogger<MyClass>>();
```

**Realistic Example**:
```csharp
// In a View or service needing other services
public class SomeService
{
    private readonly IWorkspaceService _workspaceService;
    
    public SomeService(IWorkspaceService workspaceService)
    {
        _workspaceService = workspaceService;
    }
}
```

**Incorrect Usage Example**:
```csharp
// BAD - Don't create services manually
var service = new WorkspaceService(); // Won't have dependencies
```

**How to test in isolation**:
```csharp
// Create test service provider
var services = new ServiceCollection();
services.ConfigureSnitcher(options => { /* test config */ });
var provider = services.BuildServiceProvider();
```

**How to mock or replace**:
- Replace service registrations in test setup
- Use test doubles for interfaces
- Mock `UIConfiguration.Features` for conditional services

## Extension & Modification Guide

**How to add new feature**:
1. Add feature flag to `UIConfiguration.Features`
2. Add conditional registration in `ConfigureServices()`
3. Register new ViewModels and services
4. Ensure proper dependency chain

**Where NOT to add logic**:
- Don't add business logic to this class
- Don't handle UI events here
- Don't perform data operations directly

**Safe extension points**:
- New service registrations in `ConfigureServices()`
- Additional configuration in `ConfigureSnitcher()`
- New logging providers in logging setup

**Common mistakes**:
- Forgetting to register new service interfaces
- Adding business logic to bootstrapper
- Blocking UI thread in initialization
- Not handling async initialization properly

**Refactoring warnings**:
- Be careful with service lifetimes (scoped vs singleton)
- Maintain registration order for dependencies
- Test feature flag combinations
- Ensure database initialization completes before use

## Failure Modes & Debugging

**Common runtime errors**:
- `InvalidOperationException`: Service not registered
- `ArgumentNullException`: Missing required service
- Database connection failures during init

**Null/reference risks**:
- `ServiceProvider` can be null before initialization
- Services may not resolve if dependencies missing
- Database service unavailable during startup

**Performance risks**:
- Too many singleton services can increase memory usage
- Synchronous database initialization would block UI
- Large service registration can slow startup

**Logging points**:
- Database initialization success/failure
- Service registration errors (via exceptions)
- Application lifecycle events

**How to debug step-by-step**:
1. Set breakpoint in `OnFrameworkInitializationCompleted()`
2. Step through `ConfigureServices()`
3. Check service provider build success
4. Verify database initialization task completion
5. Validate main window DataContext assignment

## Cross-References

**Related classes**:
- `Program.cs` - Application entry point
- `SnitcherMainViewModel` - Main window ViewModel
- `SnitcherConfiguration` - Database configuration
- `UIConfiguration` - Feature flags

**Upstream callers**:
- Avalonia framework (creates App instance)
- `Program.Main()` (starts application)

**Downstream dependencies**:
- All registered services and ViewModels
- Database layer via `SnitcherConfiguration`
- Proxy services via feature flags

**Documents to read before/after**:
- Before: `Program.cs` (entry point)
- After: `SnitcherMainViewModel.cs` (main UI logic)
- After: `SnitcherConfiguration.cs` (database setup)

## Knowledge Transfer Notes

**Reusable concepts**:
- Avalonia application bootstrapping pattern
- Conditional service registration with feature flags
- Async database initialization pattern
- Centralized logging configuration
- DI container setup for desktop applications

**Project-specific elements**:
- Snitcher-specific service interfaces
- SQLite database configuration
- Proxy inspection service registration
- Custom `SnitcherLoggerAdapter` for legacy logging

**How to recreate pattern elsewhere**:
1. Create App class inheriting from Avalonia Application
2. Implement `OnFrameworkInitializationCompleted()`
3. Set up ServiceCollection in `ConfigureServices()`
4. Register services with appropriate lifetimes
5. Build provider and resolve main ViewModel
6. Handle async initialization in background

**Key insights**:
- Keep bootstrapper focused on infrastructure only
- Use feature flags for modular architecture
- Initialize heavy resources asynchronously
- Provide global service access sparingly
- Log initialization steps for debugging
